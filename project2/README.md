#说明文档
* ### The maximum-subarray problem:
1.暴力算法：遍历穷尽给定数组的所有连续子数组，比较各个子数组的元素之和，最后求得一个最大连续子数组之和。算法的时间复杂度为`O(n^3)`（子数组数量`O(n^2)`，子数组求和`O(n)`）。通过滑动窗口来实现。

2.动态规划算法：`Kadane's algorithm`，思路，设置辅助的和`sum2`，如果`sum2`小于`0`表明需要重置为下一个子数组，否则累加，只要`sum1<sum2`就表明需要更新`sum1`。(算法复杂度`O(n)`)。

3.分治法：分治的策略：将数组均分为两个部分，那么最大子数组会存在于：左侧数组的最大子数组、右侧数组的最大子数组、左侧数组的以右侧边界为边界的最大子数组+右侧数组的以左侧边界为边界的最大子数组。(复杂度`O(nlgn)`)

4.三种算法对不同规模问题的处理时间实验(程序运行时间)结果：
实验数据见`excel`表，设置的运行试验时间差为`2000ns`，同时问题规模在`2-300`之间，根据以上实验数据：暴力-动态：大概在`5`或`6`左右，暴力-分治：大概在`48-55`左右和`124`左右，分治-动态的时间差不符合设定的要求。

5.1-2：动态规划算法中，设置初始的和`sum1`和辅助和`sum2`为`0`，因为如果辅助和`sum2`小于`0`就要重新确定最大和数组的起点，整个数组全为负数，最大数组的起点一直在更新，最后不能赋值给`sum1`，`sum1`就为初始值`0`。其他两种算法直接看最后的结果，如果最大数组和小于`0`置为`0`就可以了。
* ### Interval-graph coloring problem：
创建一个活动类对象，其中包括一个活动的开始与结束时间、序号、被安排到的空间、是否已经被安排过等属性，首先确定活动的数量，将所有的活动根据结束时间按照快速排序的方法排序，然后依次遍历活动，开辟空间，将该空间最后一个活动的结束时间设置为该空间的结束时间，活动的开始时间晚于空间的结束时间就将该活动加入该空间，直至这个空间无法再安排为止(就是遍历了一遍活动之后)，这时如果还有活动没有安排，就开辟新的空间，重新遍历活动。

算法复杂度分析：首先对`n`个活动使用快速排序，复杂度为`O(nlgn)`，依次对每个空间使用贪心算法，所以复杂度为`O(n^2)`,即为`O(n^2)`。

* ### Beam Search
`Beam Search` 对贪心搜索进行了改进，扩大了搜索空间，更容易得到全局最优解。`Beam Search` 包含一个参数 `beamSize k`，表示每一时刻均保留得分最高的`k`个序列，然后下一时刻用这`k`个序列继续生成，相当于写个`k`叉树，只是中间省去了许多的分叉，根节点设置为空，选出`k`个概率最高的节点，然后`k`个节点的儿子中再选`k`个概率最大的节点，以此类推，概率我取的是随机数，然后根据最后一个节点遍历回去得到最终的序列。例子：`"人类","上帝","思考","发笑"`四个词按照上述过程根据概率得到的序列。

暴力搜索：类似于宽度优先算法，层层处理树的每一个节点，得到全部解，算法复杂度高，效率低。

贪心搜索：在对问题求解时，总是做出当前情况下的最好选择，每次选择得到的都是局部最优解。选择的策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

束搜索：一种启发式图搜索算法，通常用在图的解空间比较大的情况下，为了减少搜索所占用的空间和时间，在每一步深度扩展的时候，剪掉一些质量比较差的结点，保留下一些质量较高的结点。这样减少了空间消耗，并提高了时间效率，但缺点就是有可能存在潜在的最佳方案被丢弃，因此`Beam Search`算法是不完全的，一般用于解空间较大的系统中。