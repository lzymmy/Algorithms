# 说明文档
*** 
* ##运行方法
* 可以在界面上任意添加地点（包括地名），将地名填入自定义地点文本框，然后鼠标单击需要添加点的位置即可
* 可以删除任意地点，输入地名，点击确认按钮
* 输入两地地名，可以添加两地之间的路径
* 初始化地图按钮给出了一个大致的模板，可以在该基础上更改线路
* 重置按钮是为了消除每次导航后页面路径的标色问题
* 输入起始地与目的地，选择需要的导航方式，即可打印出最短路径和路程，图中路径会以红色标出
* 黑色的线路是普通线路，蓝色的点是普通地点，黄色的线路是公交线路，黄色的点是公交站，红色的线路是得到的最短路径

* ##注意事项
* 默认任何地名都不重复
* 步行导航的两点之间必须是连通的，不然找不到路径
* 公交导航起始地与目的地不能是公交线路上的地点，两地不与公交站点相连
* 每次导航后都要点击重置按钮，不然会报错

* ##算法：
* 程序使用`Dijkstra(迪杰斯特拉)`算法
* 原因：地图上的路径肯定是无负权的，有环的，不能选择`Floyd算法`，所以选择使用`Dijkstra算法`或者`Bellman-Ford算法`
* 算法简介：`Dijkstra(迪杰斯特拉)`算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。通过`Dijkstra`计算图`G`中的最短路径时，需要指定起点`s`(即从顶点`s`开始计算)。此外，引进两个集合`S`和`U`。`S`的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而`U`则是记录还未求出最短路径的顶点(以及该顶点到起点`s`的距离)。初始时，`S`中只有起点`s`；`U`中是除`s`之外的顶点，并且`U`中顶点的路径是”起点`s`到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到`S`中；接着，更新`U`中的顶点和顶点对应的路径。 然后，再从`U`中找出路径最短的顶点，并将其加入到`S`中；接着，更新`U`中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。
* 算法使用与复杂度：程序有一个地点类，其中包括了地点的名称、位置等基本属性，`javafx`中地点用圆表示。整体来说公交导航与步行导航是完全独立且相似的，所以我以步行导航来做简介。将地点与路径保存在对应的`Arraylist`数组中，同时用map将地点与路径相关联。这就是整个框架。
对各个地点标号（以便矩阵查找），依据`map`得到表示地点与地点之间关系的邻接矩阵，两点相连对应矩阵位置用距离表示，同点表示为`0`，不相连表示为任意一个很大的数`M`，然后按照上面算法的逻辑就可以得到最短距离以及这条最短路径的标号顺序，再通过标号顺序得到地点顺序，最后反馈到`UI界面`上。算法本身其实是得到了给定的起点到达其他任意一个点的最短路径，复杂度为`O(n^2)`。
  
* ##性能分析：
* 测试了从`a`点分别以步行和公交到达其他任意一点最短路径程序运行时间，详情见`project3实验数据.xlsx`表

* 从表中得到： 对于步行，整体趋势是当最短路径字符串前缀相似时，字符串越长，耗时越短，这可以反向证明对于这个程序而言搜索路径(`Dijkstra算法`)并不是影响这个程序运行时间的最大因素，最大因素可能还是在依据路径绘制路径的阶段，公交的话没有什么明显的特征。

